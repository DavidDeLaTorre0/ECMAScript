DOCUMENTACION 

Repositorios y Recursos (Muy bueno para estar al dia)
https://github.com/tc39/ecma262#ecmascript

------------------ECMASCRIPT------------------

EXTENSIONES PARA VS
    1-LIVE SERVER
    2-CODE RUNNER
    3-JAVASCRIPT(ES6)

------------------------------

PARA TRABAJAR CON GIT (OJO INFO IMPORTANTE)

    -GIT INIT(INICIALIZAR UN REPOSITORIO LOCAL)
    -NPM INIT (MEJOR SIN -Y)(CON -Y PARA UNA CONFIGURACION POR DEFECTO)
        -PEDIRÁ:
            -Descripcion:"Que tipoo de proyecto es"
            -entry point: dejamos index por DEFECTO(punoit de entrada a tu app)
            -test command: (nada, no añadimos pruebas, si las vas a añadir las añades aqui)
            -git repositoy: enlace del repo de git(se puede poner mas tarde)
            -key words: "javascript,ecmascript"
            -author: David De La Torre
            -lisense:(ISC) MIT(licencia facil  y permisiva)
    -TODO ESTO NOS INCIALIZA UN PACKAGE.JSON

-----------------------------------------------------
dentro de la carpeta src es un estandar
    aqui es donde va a viviur cada bloque de codigo que nosotros creamos,
    vamos a crear varias carpetas dependiendo de las versiones partiendo de la principal version es6

creamos carpeta es6
aqui vamos a tener nuestro archivos, crearemos archivos por cada una de las principales caracteristicas que se han agregado y las vamos a ir probando

-------------------------------------------------------------------------
        ARROW FUNCTIONS--- FUNCIONES FLECHA

Una expresión de función flecha es una alternativa compacta a una expresión de función tradicional, pero es limitada y no se puede utilizar en todas las situaciones.

Diferencias y limitaciones:

No tiene sus propios enlaces a this o super y no se debe usar como métodos.
No tiene argumentos o palabras clave new.target.
No apta para los métodos call, apply y bind, que generalmente se basan en establecer un ámbito o alcance
No se puede utilizar como constructor.
No se puede utilizar yield dentro de su cuerpo.
------------------------------------------------------
        MODULOS
uadno hagamos el import y el expor algun modulo, en el archivo package.json hay que aañadir lo siguiente:
  "type": "module" debajo de license
---------------------------------------------------
Iteradores y generadores

Procesar cada uno de los elementos en una colección es una operación muy común. JavaScript proporciona diversas formas de iterar sobre una colección, desde simples bucles for hasta métodos como map() y filter(). Los iteradores y los generadores traen el concepto de iteración al centro del lenguaje y proporcionan un mecanismo para personalizar el comportamiento de los bucles for...of.


En JavaScript, un iterador es un objeto que permite recorrer una colección y devolver un valor al terminar.

Específicamente, un iterador es un objeto que implementa el protocolo de iteración a través del método next(), el cual devuelve un objeto con dos propiedades:

value
El siguiente valor en la secuencia de iteración.

done
Es true si el último valor en la secuencia ya ha sido consumido. Si value está presente junto con done, es el valor de retorno del iterador.

Un iterador se considera ya terminado/finalizado cuando la invocación de next() regresa un objeto donde la propiedad done es verdadero.

Una vez creado, un objeto iterador puede utilizarse explícitamente llamando repetidamente al método next().

function crearIterador(arreglo){
    var siguienteIndice = 0;

    return {
       next: function(){
           return siguienteIndice < arreglo.length ?
               {value: arreglo[siguienteIndice++], done: false} :
               {done: true};
       }
    }
}

Una vez inicializado, se puede invocar al método next() para acceder a las parejas llave-valor del objeto en cuestión:

var it = crearIterador(['yo', 'ya']);
console.log(it.next().value); // 'yo'
console.log(it.next().value); // 'ya'
console.log(it.next().done);  // true

--------------------------------------------------------------------------------------------------------
Generadores

Aunque los iteradores personalizados son una herramienta útil, su creación require una programación meticulosa ya que necesitan mantener su estado interno explícitamente. Los generadores son una alternativa poderosa: permiten definir un algoritmo iterativo al escribir una sola función que puede mantener su propio estado.

Una función generadora (constructor GeneratorFunction) es un tipo especial de función que sirve como una fábrica de iteradores. Cuando se ejecuta, regresa un nuevo objeto Generador. Una función se convierte en una Función Generadora si utiliza la sintáxis function*.

function* hacedorIds() {
  var indice = 0;
  while(true)
    yield indice++;
}

var gen = hacedorIds();

console.log(gen.next().value); // 0
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
// ...
-----------------------------------------------------------------------------------------
Iterables
Un objeto es iterable si define cómo se itera. Un ejemplo son los valores que se iteran en un bucle for...of. Algunos tipos integrados de datos, como Array o Map (en-US), tienen una forma de iteración ya definida, mientras que otras no (como Object).

Con el fin de ser iterable, un objeto debe implementar el método @@iterator. Esto quiere decir que dicho objeto (o alguno en su cadena de prototipos) debe tener una propiedad definida usando la llave Symbol.iterator. Esta función debería regresar un nuevo iterador en cada invocación, pero no es obligatorio.

Iterables definidos por el usuario
Podemos hacer nuestros propios objetos iterables de este modo:

var miIterable = {}
miIterable[Symbol.iterator] = function* () {
    yield 1;
    yield 2;
    yield 3;
};

for (let valor of miIterable) {
    console.log(valor)
}
// 1
// 2
// 3

// ó

[...miIterable] // [1, 2, 3]
----------------------------------------------------------------------
Iterables integrados
String, Array, Objetos_globales/TypedArray, Map (en-US) y Set son iterables ya integrados, porque todos sus objetos prototipo tienen un método definido con la llave Symbol.iterator.

Sintaxis que esperan objetos iterables
Algunas sentencias y expresiones esperan objetos iterables, por ejemplo los bucles for-of, el operador de propagación, yield*, y la asignación por desestructuración.

for(let valor of ["a", "b", "c"]){
    console.log(valor)
}
// "a"
// "b"
// "c"

[..."abc"] // ["a", "b", "c"]

function* gen(){
  yield* ["a", "b", "c"]
}

gen().next() // { value:"a", done:false }

[a, b, c] = new Set(["a", "b", "c"])
a // "a"
-----------------------------------------------------------------------
Generadores avanzados
Los generadores calculan los valores devueltos bajo demanda, lo que les permite representar eficientemente secuencias que son costosas de calcular, o incluso secuencias infinitas como se explicó anteriormente.

El método next() también acepta un valor que puede ser utilizado para modificar el estado interno del generador. El valor recibido por next() es utilizado como si fuera el resultado de la iteración anterior (último valor entregado por yield) el cual detuvo al generador.

A continuación se muestra un generador de Fibonacci usando next(x) para reiniciar la secuencia:

function* fibonacci(){
  var fn1 = 1;
  var fn2 = 1;
  while (true){
    var actual = fn2;
    fn2 = fn1;
    fn1 = fn1 + actual;
    var reset = yield actual;
    if (reset){
        fn1 = 1;
        fn2 = 1;
    }
  }
}

var secuencia = fibonacci();
console.log(secuencia.next().value);     // 1
console.log(secuencia.next().value);     // 1
console.log(secuencia.next().value);     // 2
console.log(secuencia.next().value);     // 3
console.log(secuencia.next().value);     // 5
console.log(secuencia.next().value);     // 8
console.log(secuencia.next().value);     // 13
console.log(secuencia.next(true).value); // 1
console.log(secuencia.next().value);     // 1
console.log(secuencia.next().value);     // 2
console.log(secuencia.next().value);     // 3

Es posible forzar a un generador a lanzar una excepción cuando se invoca al método throw() y se pasa el valor de excepción a lanzar. Esta excepción será lanzada desde el contexto actual suspendido del generador, como si en vez del estado suspendido actualmente de yield se tuviera una sentencia throw valor.

Si la excepción no es atrapada dentro del generador, se propagará a la invocación de throw(), y las siguientes llamadas a next() tendrán a la propiedad done en verdadero.

Los generadores tienen un método return(valor) que regresa el valor enviado y finalizan al generador.

------------------------------------------------------------------------------------------------------------------
REGEX

RegExp.prototype.exec()

El método exec() ejecuta una busqueda sobre las coincidencias de una expresión regular en una cadena especifica. Devuelve el resultado como array, o null.

Si está ejecutando una expresión regular solo para buscar si algo se cumple o no, usa el método RegExp.prototype.test() o el método String.prototype.search()

Sintaxis
regexObj.exec(cadena)

Valor devuelto
Si se encuentran coincidencial, el método exec() devuelve un array y actualiza las propiedades del objeto de la expresión regular. El array devuelto contiene los elementos encontrados en su primer elemento, y un elemento por cada parte de la expresión regular que se encuentra entre parentesis y se encuentra dentro del texto que fué capturado.

Si la busqueda falla, el método exec() devuelve null.

// Busca "quick brown" seguido de "jumps", ignorando los caracteres que se
// encuentren entre medias.
// Recuerda "brown" y "jumps"
// Ignora mayusculas y minusculas
var re = /quick\s(brown).+?(jumps)/ig;
var result = re.exec('The Quick Brown Fox Jumps Over The Lazy Dog');





La siguiente tabla muestra el resultado de este script:

Objeto	    Propiedad/Índice	                    Descripción	                                                     Ejemplo
result	{ 
            [0]	                Todas las partes de la cadena que cumplen la expresión regular	                Quick Brown Fox Jumps
            -------------------------------------------------------------------------------------------------------------------------------
            [1],...[n]	        Las subcadenas entre parentesis que han sido encontradas, si hay alguna.        [1] = Brown [2] = Jumps
                                El número de subcadenas encontradas es ilimitado
            -------------------------------------------------------------------------------------------------------------------------------
            index	            El índice de base-0 del elemento encontrado en la cadena.	                            4
            -------------------------------------------------------------------------------------------------------------------------------
            input	                             La cadena original.	                                The Quick Brown Fox Jumps Over The Lazy Dog
}
-------------------------------------------------------------------------------------------------------------------------------------------------
re	{
            lastIndex	        El índice sobre el cual empieza la siguiente busqueda.                                  25
                                Cuando no se usa g (busqueda global), esto va a ser siempre 0.	
            --------------------------------------------------------------------------------------------------------------------------------------
            ignoreCase	        Indica si la bandera "i" ha sido usada para ignorar mayusculas y minusculas.	        true
            --------------------------------------------------------------------------------------------------------------------------------------
            global	            Indica si la bandera "g" fue usada para hacer una busqueda global.	                    true
            --------------------------------------------------------------------------------------------------------------------------------------
            multiline	        Indica si la bandera "m" fue usada para buscar en cadenas sobre multiples lineas	    false
            --------------------------------------------------------------------------------------------------------------------------------------
            source	            El texto del patrón de busqueda                                             	quick\s(brown).+?(jumps)
}
-------------------------------------------------------------------------------------------------------------------------------------------------

FLAT

Array.prototype.flat()
Experimental: Esta es una tecnología experimental
Comprueba la Tabla de compabilidad de navegadores cuidadosamente antes de usarla en producción.

El método flat() crea una nueva matriz con todos los elementos de sub-array concatenados recursivamente hasta la profundidad especificada.

{{EmbedInteractiveExample("pages/js/array-flat.html")}}

Sintaxis
var newArray = arr.flat([depth]);
Parámetros
depth Opcional
El nivel de profundidad que especifica qué tan profunda debe aplanarse una estructura de matriz anidada. El valor predeterminado es 1.

Valor de retorno
Una nueva matriz con los elementos de la sub-matriz concatenados en ella.

Ejemplos
Aplanar matrices anidadas
var arr1 = [1, 2, [3, 4]];
arr1.flat();
// [1, 2, 3, 4]

var arr2 = [1, 2, [3, 4, [5, 6]]];
arr2.flat();
// [1, 2, 3, 4, [5, 6]]

var arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2);
// [1, 2, 3, 4, 5, 6]

Aplanamiento y huecos de matriz
El método de aplanar elimina las ranuras vacías en las matrices:

var arr4 = [1, 2, , 4, 5];
arr4.flat();
// [1, 2, 4, 5]

-------------------------------------------------------------------------------------------------------------------------------------------------
FLATMAP
Array.prototype.flatMap()

El método flatMap() primero mapea cada elemento usando una función de mapeo, luego aplana el resultado en una nueva matriz. 
Es idéntico a un map seguido de un flatten (en-US)de profundidad 1, pero flatMap es a menudo útil y la fusión de ambos en un método es ligeramente más eficiente.

Sintaxis
var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) {
    // return element for new_array
}[, thisArg])

Parámetros

callback
Función que produce un elemento de la nueva matriz, tomando tres argumentos:

currentValue
El elemento actual que se procesa en la matriz.

indexOpcional
El índice del elemento actual que se procesa en la matriz.

arrayOpcional
La matriz map fue llamada.

thisArgOpcional
Valor para usar como this al ejecutar callback.

Valor de retorno
Una nueva matriz con cada elemento es el resultado de la función de devolución de llamada y se aplana a una profundidad de 1.

Descripción
Ver Array.prototype.map() para una descripción detallada de la función de devolución de llamada. El método flatMap es idéntico a map seguido de una llamada a flatten (en-US) de profundidad 1.

Ejemplos
map y flatMap
var arr1 = [1, 2, 3, 4];

arr1.map(x => [x * 2]);
// [[2], [4], [6], [8]]

arr1.flatMap(x => [x * 2]);
// [2, 4, 6, 8]

// solo un nivel es aplanado
arr1.flatMap(x => [[x * 2]]);
// [[2], [4], [6], [8]]

-------------------------------------------------------------------------------------------------------------------
fromEntries

Object.fromEntries()
El método Object.fromEntries() transforma una lista de pares con [clave-valor] en un objeto.


const entries1 = new Map([
    ['foo', 'bar'],
    ['baz', 42]
  ]);
  
  const obj = Object.fromEntries(entries1);
  
  console.log(obj);
  // expected output: Object { foo: "bar", baz: 42 }

  Sintaxis

Object.fromEntries(iterable);

Parámetros

iterador
Un iterador como Array, Map (en-US) u otros objetos que implementen el protocolo iterable.

Valor de retorno
Un nuevo objeto cuyas propiedades son dadas por las entradas del iterador.

Descripción
El método Object.fromEntries() toma una lista de pares con clave-valor y devuelve un nuevo objeto cuyas propiedades son dadas por éstas entradas. El argumento iterador se espera que sea un objeto que implemente un método @@iterator, que devuelve un objeto iterador, que produce un objeto tipo array de dos elementos, donde el primer elemento es un valor que se usará como la clave de la propiedad, y el segundo elemento es el valor a asociar con esa clave de propiedad.

Object.fromEntries() realiza lo inverso de Object.entries().
